<h1>utp-cls2</h1>

<h2>Lamcomb - zad1</h2>

<br><br>Zbudować
klasę InputConverter, która pozwala&nbsp;przekształcić dane wejściowe
(ustalane w konstruktorze klasy) za pomocą funkcji, podanych jako
argumenty metody convertBy.<br><br>Np. jeśli mamy zdefiniowane operacje (funkcje):<br><ul><li>flines - zwraca listę wierszy z pliku tekstowego</li><li>join - łączy napisy z listy (zwraca napis połączonych ze sobą elementów listy napisów)</li><li>collectInts - zwraca listę liczb całkowitych zawartych w napisie</li><li>sum - zwraca sumę elementów listy liczb całkowitych</li></ul>to sumę liczb całkowitych, występujących w pliku o nazwie <span style="font-style: italic;">fname</span> możemy uzyskać poprzez: <br><pre>Integer s =&nbsp;new InputConverter&lt;String&gt;(fname).convertBy(flines, join, collectInts, sum); <br></pre>a listę liczb całkowitych z napisu txt tak:<br><pre>List&lt;Integer&gt; n =&nbsp;new InputConverter&lt;String&gt;(txt).convertBy(collectInts);</pre><br><span style="font-weight: bold;">Istotą
metody convertBy jest to, że pozwala ona w różny sposób kombinować
różne&nbsp;operacje na różnych danych i łatwo uzyskiwać wyniki.</span><br><br>Zapewnić
prawidłowe działanie następującego fragmentu kodu (dostarczonego w
szablonie projektu, pliku Main.java nie wolno modyfikować):<br><pre>  public static void main(String[] args) {<br>    /*&lt;--<br>     *  definicja operacji w postaci lambda-wyrażeń:<br>     *  - flines - zwraca listę wierszy z pliku tekstowego<br>     *  - join - łączy napisy z listy (zwraca napis połączonych ze sobą elementów listy napisów)<br>     *  - collectInts - zwraca listę liczb całkowitych zawartych w napisie<br>     *  - sum - zwraca sumę elmentów listy liczb całkowitych<br>     */<br><br>    String fname = System.getProperty("user.home") + "/LamComFile.txt"; <br>    InputConverter&lt;String&gt; fileConv = new InputConverter&lt;&gt;(fname);<br>    List&lt;String&gt; lines = fileConv.convertBy(flines);<br>    String text = fileConv.convertBy(flines, join);<br>    List&lt;Integer&gt; ints = fileConv.convertBy(flines, join, collectInts);<br>    Integer sumints = fileConv.convertBy(flines, join, collectInts, sum);<br><br>    System.out.println(lines);<br>    System.out.println(text);<br>    System.out.println(ints);<br>    System.out.println(sumints);<br><br>    List&lt;String&gt; arglist = Arrays.asList(args);<br>    InputConverter&lt;List&lt;String&gt;&gt; slistConv = new InputConverter&lt;&gt;(arglist);  <br>    sumints = slistConv.convertBy(join, collectInts, sum);<br>    System.out.println(sumints);<br><br>  }</pre>Dla następujących danych z pliku:<br><pre>Cars:<br>- Fiat: 15, Ford: 20<br>- Opel: 8, Mitsubishi: 10</pre><br>oraz &nbsp;nastepujących argumentów wywołania metody main:<br><pre>Warszawa 100 Kielce 200 Szczecin 300</pre>program powinien wyprowadzić na konsolę:<br><pre>[Cars:, - Fiat: 15, Ford: 20, - Opel: 8, Mitsubishi: 10]<br>Cars:- Fiat: 15, Ford: 20- Opel: 8, Mitsubishi: 10<br>[15, 20, 8, 10]<br>53<br>600</pre><span style="font-weight: bold;">Uwaga:
w klasie InputConverter musi występować tylko jedna metoda o nazwie
convertBy (czyli w tym zadaniu nie dopuszczamy przeciążania metody
convertBy).</span><br style="font-weight: bold;"><pre></pre>

<h2>Maybe - zad2</h2>
<br><br>
Zdefiniować klasę Maybe o następujących właściwościach.<br><br>Obiekty
Maybe reprezentują&nbsp;kontenery, które mogą zawierać lub nie
pojedynczą wartość. Motywacją do wprowadzenia takiej konstrukcji jest
ułatwienie programowania w sytuacji, gdy zmienna może mieć wartość
null, szczególnie kiedy wymagane jest jej dalsze bezpieczne
przetwarzanie (na przykład za pomocą lambda-wyrażeń, oznaczających
jakieś funkcje). Bezpieczne - to znaczy takie, które nie powoduje
wyjątku NullPointerException.<br><br>Obiekty typu Maybe zawierają jakąś wartość lub są puste (nigdy nie powinny mieć wartości null). <br>W klasie Maybe zdefiniować następujące metody:<br><ul><li><span style="font-weight: bold;">Maybe.of(x) </span>- ta metoda statyczna zwraca obiekt Maybe, „opakowujący” wartość x, dowolnego typu referencyjnego. </li><li><span style="font-weight: bold;">void ifPresent(Consumer cons)</span>&nbsp;
- jeżeli w obiekcie Maybe znajduje się wartość, wykonywana jest
operacja cons z tą wartością jako argumentem, w przeciwnym razie - gdy
obiekt Maybe jest pusty - nic się nie dzieje.</li><li><span style="font-weight: bold;">Maybe map(Function func)</span>
-&nbsp; jeżeli w obiekcie&nbsp; jest wartość, wykonywana jest funkcja
func z tą wartością jako argumentem i zwracany jest jej wynik
„zapakowany” w nowy obiekt klasy Maybe (to opakowanie jest niezbędne,
bo wynik mógłby być null, a tego chcemy uniknąć w ewentualnym dalszym
przetwarzaniu; jeśli wynikiem funkcji jest null, zwracany jest pusty
obiekt klasy Maybe).</li><li><span style="font-weight: bold;">T get()</span> zwraca zawartość obiektu Maybe, ale jeśli jest on pusty, powinna zgłosić wyjątek NoSuchElementException.</li><li><span style="font-weight: bold;">boolean isPresent() </span>- zwraca true jeśli w obiekcie Maybe zawarta jest wartośc, a false - gdy jest on pusty</li><li><span style="font-weight: bold;">T orElse(T defVal)</span> - zwraca zawartość obiektu Maybe lub domyślną wartosć defVal, jeśli obiekt Maybe jest pusty.</li><li><span style="font-weight: bold;">Maybe filter(Predicate pred)</span>
&nbsp;- zwraca&nbsp; to Maybe, jeśli spełniony jest warunek pred lub to
Maybe jest puste; zwraca puste Maybe, jeśli warunek pred jest
niespełniony.</li></ul>Klasę Maybe przetestować na przykładzie następującej &nbsp;klasy&nbsp;Main::<br><br><pre>        public class Main {<br><br>          public static void test() {<br>            // Metoda of(...)<br>            String s = "aaa";    <br>            Maybe&lt;String&gt; m1 = Maybe.of(s);<br>            System.out.println(m1);<br>            s = null;<br>            Maybe&lt;String&gt; m2 = Maybe.of(s);<br>            System.out.println(m2);<br><br>            // Metoda ifPresent(...)<br>            Integer num = null;<br>            Maybe&lt;Integer&gt; m4 = Maybe.of(num);<br>            // ZAMIAST<br>            if (num != null) System.out.println(num);<br>            // PISZEMY<br>            m4.ifPresent(n -&gt; System.out.println(n));<br>            // A NAWET<br>            m4.ifPresent(System.out::println);<br><br>            Maybe&lt;Integer&gt; m5 = Maybe.of(10);<br>            m5.ifPresent(System.out::println);<br><br>            // Metoda map()<br>            Maybe&lt;Integer&gt; m6 = m5.map( n -&gt; n +10 ); <br>            System.out.println(m6);<br><br>            // Metoda get()<br>            System.out.println(m6.get());<br>            try {<br>              System.out.println(m4.get());<br>            } catch(Exception exc) {<br>              System.out.println(exc);<br>            }<br><br>            // Metoda orElse()<br>            // ZAMIAST<br>            String snum = null;<br>            if (num != null) snum = "Wartość wynosi: " + num;<br>            if (snum != null) System.out.println(snum);<br>            else System.out.println("Wartość niedostępna");<br><br>            //MOŻNA NAPISAĆ<br>            String res = Maybe.of(num).map(n -&gt; "Wartość wynosi: "+n)<br>                              .orElse("Wartość niedostępna");<br>            System.out.println(res);<br><br>            // I filter(...)<br><br>            String txt = "Pies";<br>            String msg = "";<br><br>            //ZAMIAST<br>            if (txt != null &amp;&amp; txt.length() &gt; 0) {<br>              msg = txt;<br>            } else {<br>              msg = "Txt is null or empty";<br>            }<br><br>            //MOŻNA NAPISAĆ<br>            msg = Maybe.of(txt)<br>                       .filter(t -&gt; t.length() &gt; 0)<br>                       .orElse("Txt is null or empty"); <br>            System.out.println(msg);<br>          }<br><br>          public static void main(String[] args) {<br>            test();<br>          }<br>        }<br>        // Wynik na konsoli:<br>        /*    <br>          Maybe has value aaa<br>          Maybe is empty<br>          10<br>          Maybe has value 20<br>          20<br>          java.util.NoSuchElementException:  maybe is empty<br>          Wartość niedostępna<br>          Wartość niedostępna<br>          Pies<br>        */</pre><br>